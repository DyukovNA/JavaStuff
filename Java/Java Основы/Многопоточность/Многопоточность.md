**Потоки** - виртуальные сущности, которые последовательно выполняют код
Потоки протекают в процессах
**Процесс** - программа, которая выполняется

Если многопоточная программа выполняется на одноядерном цп, то цп так часто переключает потоки, что кажется, что они выполняются парллельно, хотя выигрыша в производительности нет

![[Снимок экрана 2025-02-13 в 21.14.04.png]]
![[Снимок экрана 2025-02-13 в 21.14.38.png]]

![[Снимок экрана 2025-02-13 в 21.15.52.png]]
![[Снимок экрана 2025-02-13 в 21.16.23.png]]
![[Снимок экрана 2025-02-13 в 21.16.45.png]]
**Разница между Thread and Runnable**: Thread - класс от которого наследуемся, а наследование только одно; Runnable - интерфейс, их может быть много.

**Различие с Callable**: Callable тоже интерфейс, но тут мы вызываем не start, а call. start - void, call что-то возвращает, например Integer. Callable используем когда мы хотим что-то вернуть из потока.

![[Снимок экрана 2025-02-13 в 21.25.07.png]]
![[Снимок экрана 2025-02-13 в 21.25.39.png]]
![[Снимок экрана 2025-02-13 в 21.27.28.png]]

![[Снимок экрана 2025-02-13 в 21.28.23.png]]
![[Снимок экрана 2025-02-13 в 21.29.46.png]]

![[Снимок экрана 2025-02-13 в 21.31.07.png]]
![[Снимок экрана 2025-02-13 в 21.33.28.png]]

В Java оператор **synchronized** привязывает блок к определённому потоку, исключая доступ других потоков в этот момент.

![[Снимок экрана 2025-02-13 в 21.34.14.png]]
![[Снимок экрана 2025-02-13 в 21.35.11.png]]

Когда отдаётся мониторы другие объекты могут пользоваться объектом к которому был применён wait(). То есть мы ожидаем когда нам этот объект вернут.
Тот объект который получил монитор изменяет (например) объект, вызывает к объекту notify(), монитор возвращается.
Что ожидающий, что принимающий должны быть синхронизированны по объекту

![[Снимок экрана 2025-02-13 в 21.43.19.png]]
![[Снимок экрана 2025-02-13 в 21.43.31.png]]

**Альтернатива** synchronized - это **locks**
![[Снимок экрана 2025-02-14 в 14.24.50.png]]
![[Снимок экрана 2025-02-14 в 14.25.21.png]]
![[Снимок экрана 2025-02-14 в 14.56.12.png]]
### Дедлоки и взаимные блокировки (Deadlocks)

[**Дедлок**](https://garden.struchkov.dev/ru/dev/fundamental/Deadlock) — это ситуация, при которой два или более потока блокируют друг друга, ожидая освобождения ресурсов, которые удерживаются другим потоком. Чтобы понять это, нужно рассмотреть, что такое «блокировки» и «ресурсы».

Простой пример дедлока:

- Поток A захватывает ресурс 1 (например, файл) и пытается получить доступ к ресурсу 2 (например, переменной), но этот ресурс уже захвачен потоком B.
- Поток B захватывает ресурс 2 и пытается получить доступ к ресурсу 1, который удерживается потоком A.

==В результате оба потока зависают — каждый ждёт освобождения ресурса, который удерживает другой поток==. Это называется дедлоком, и программа перестаёт выполнять свои задачи, так как ни один из потоков не может продолжить работу.
![[Снимок экрана 2025-02-14 в 14.59.53.png]]
![[Снимок экрана 2025-02-14 в 15.00.44.png]]
![[Снимок экрана 2025-02-14 в 15.02.10.png]]
![[Снимок экрана 2025-02-15 в 02.26.28.png]]
![[Снимок экрана 2025-02-15 в 02.28.06.png]]
![[Снимок экрана 2025-02-15 в 02.29.07.png]]
Пример:
![[Снимок экрана 2025-02-15 в 02.29.39.png]]
![[Снимок экрана 2025-02-15 в 02.30.43.png]]
![[Снимок экрана 2025-02-15 в 02.31.27.png]]
![[Снимок экрана 2025-02-15 в 02.33.29.png]]
Сами создали вызываемый объект
![[Снимок экрана 2025-02-15 в 02.34.40.png]]







### Параллелизм и конкурентность

Для полного понимания важно разграничить такие термины, как «**Конкурентность**» (Concurrency) и «**Параллелизм**». Их часто путают, но они играют разные роли в многозадачной среде.

[**Конкурентность**](https://garden.struchkov.dev/ru/dev/fundamental/Concurrency) — это общий термин, описывающий способность программы обрабатывать несколько задач. ==Это не обязательно означает одновременное выполнение==. Конкурентные программы могут [переключаться между задачами](https://garden.struchkov.dev/ru/dev/fundamental/%D0%9F%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0), создавая иллюзию параллельного выполнения, даже если задачи фактически выполняются последовательно.

[**Параллелизм**](https://garden.struchkov.dev/ru/dev/fundamental/Parallelism) — один из методов реализации конкурентности. Он предполагает ==выполнение нескольких задач одновременно, каждая из которых выполняется независимо от других==.

### Определение многопоточности

**Многопоточность** — это метод реализации конкурентности, при котором несколько задач выполняются в виде отдельных потоков внутри одного процесса. Этот подход позволяет программам выполнять параллельно несколько операций, что особенно важно для оптимизации ресурсов современных многоядерных систем.

[**Закон Амдала**](https://garden.struchkov.dev/ru/dev/fundamental/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD-%D0%90%D0%BC%D0%B4%D0%B0%D0%BB%D0%B0) описывает пределы ускорения программы при увеличении числа потоков. Даже ==если большая часть программы может быть распараллелена, всегда останется часть, которая выполняется последовательно. Эта последовательная часть становится “узким горлышком” и ограничивает прирост производительности==. В результате, по мере увеличения числа потоков, прирост производительности начинает уменьшаться.

[Закон универсальной масштабируемости](https://garden.struchkov.dev/ru/dev/fundamental/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD-%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D0%B8) (Закон Буттлера) идёт дальше, объясняя, почему ==производительность может даже снижаться при увеличении числа потоков==. Он учитывает два ключевых фактора:

- **Координационные затраты**: С ростом числа потоков возрастает необходимость их синхронизации и координации. Это требует дополнительных ресурсов и времени.
- **Конкуренция за ресурсы**: Потоки начинают конкурировать за ограниченные ресурсы системы, такие как процессорное время, память или доступ к файлам.



## Синхронизация потоков

Синхронизация необходима для предотвращения гонок данных и обеспечения согласованности состояния программы при одновременном доступе нескольких потоков к общим ресурсам. ==Синхронизация гарантирует, что один поток завершит работу с ресурсом до того, как другой поток получит к нему доступ.==

Основные механизмы синхронизации включают:

- **Мьютексы** — блокировки, которые гарантируют, что только один поток может работать с ресурсом в любой момент времени.
- **Семафоры** — ограничивают количество потоков, которые могут одновременно работать с ресурсом.
- **Мониторы (synchronized)** — в Java оператор synchronized привязывает блок к определённому потоку, исключая доступ других потоков в этот момент.

## Архитектура потоков в Java

==Каждый поток в Java представлен объектом класса `Thread`==. Хотя управление потоками осуществляется внутри JVM, ==фактически потоки работают на уровне операционной системы==. Такие потоки называются **платформенными**.

Когда запускается платформенный поток, ==JVM передаёт управление этим потоком операционной системе, которая выделяет необходимые ресурсы (например, процессорное время) и начинает его выполнение==. Этот механизм называется **многопоточностью на уровне ОС** (OS-level threads). Количество потоков, которые могут выполняться одновременно, зависит от возможностей операционной системы и числа ядер процессора.

Состояние гонки возникает, когда два или более потока одновременно пытаются получить доступ к одному и тому же ресурсу (например, переменной), причём хотя бы один поток изменяет его значение. В таких случаях порядок выполнения потоков не гарантирован, что приводит к непредсказуемому поведению программы. Например, один поток может записывать данные, в то время как другой — читать, что вызывает некорректные результаты.

## Создание потока

В Java всё является объектами, и потоки — не исключение. Класс `java.lang.Thread` — это основной инструмент для создания и управления потоками. Например, для создания и запуска 10 потоков необходимо создать 10 объектов этого класса.

Существует несколько способов создания платформенного потока:

- Наследование от класса `Thread` и переопределение метода `run()`.
- Реализация интерфейса `Runnable` и передача его экземпляра в конструктор `Thread`.

Cейчас потоки уже не создают напрямую — лучше использовать более высокоуровневые инструменты

### Способ 1: Наследование от класса `Thread`

```java
class MyThread extends Thread {
    public void run() {
        // Код для выполнения в отдельном потоке
        System.out.println("Поток " + getName() + " начал выполнение.");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // Создание нового потока
        MyThread myThread = new MyThread();
        // Запуск нового потока
        myThread.start();

        System.out.println("Основной поток продолжает выполнение.");
    }
}
```

Наследование от `Thread` накладывает ограничение: класс может наследоваться только от одного суперкласса. Это может стать проблемой, если ваш класс уже наследует другой класс.

### Способ 2: Использование интерфейса `Runnable`

Часто более предпочтительным является использование интерфейса `Runnable`. Он содержит метод `run()`, который вы должны реализовать, а затем передать экземпляр этого класса в конструктор `Thread`.

```java
class MyRunnable implements Runnable {
    public void run() {
        // Код для выполнения в этом потоке
    }
}

// Создание и запуск нового потока
Thread thread = new Thread(new MyRunnable());
thread.start();
```

Этот подход более гибкий, так как ваш класс может наследовать от другого класса, если это необходимо.

#### Способ 3: Использование лямбда-выражений

Начиная с Java 8, вы можете использовать лямбда-выражения для упрощения кода:

```java
Thread thread = new Thread(() -> {
    // Код для выполнения в этом потоке
});
thread.start();
```

Это особенно удобно для создания простых потоков без необходимости создания отдельного класса.

### Разница между `start()` и `run()`

Важно понимать различие между вызовами методов `start()` и `run()`:

`start()` — метод класса `Thread`, который создает новый поток и вызывает метод `run()` в этом новом потоке. Вызов `start()` инициирует параллельное выполнение потока.

`run()` — это метод, содержащий код, который будет выполнен в потоке. ==Если вызвать `run()` напрямую, без вызова `start()`, код будет выполнен в текущем потоке, как обычный метод, и новый поток не будет создан==.

## Управление потоками

После создания потока с помощью класса `Thread` управление его выполнением осуществляется через несколько ключевых методов:

- `start()`: Запускает поток. Важно помнить, что ==именно вызов `start()` приводит к тому, что JVM создаёт новый поток== выполнения и вызывает метод `run()` этого потока.
- `join()`: Заставляет текущий поток дождаться завершения другого потока, у которого вызван этот метод, прежде чем продолжить выполнение программы. Это полезно, когда нужно убедиться, что определённый поток завершил свою работу перед продолжением.
- `sleep()`: Приостанавливает выполнение текущего потока на заданный промежуток времени, освобождая ресурсы процессора для других потоков. После истечения указанного времени поток продолжит выполнение.

## Жизненный цикл потока

![[Pasted image 20250121102440.png]]

## Daemon threads

**Демон-поток** — это специальный тип потока, который выполняет фоновые задачи и не блокирует завершение программы. В отличие от обычных (пользовательских) потоков, ==демон-потоки автоматически завершаются, как только все пользовательские потоки программы завершили свою работу==. Это означает, что JVM не будет ждать завершения демон-потоков при завершении приложения.

Демон-потоки полезны для выполнения задач, которые должны работать в фоновом режиме, таких как мониторинг ресурсов системы, сборка мусора или выполнение периодических очисток.

## Приоритеты потоков

Каждый поток имеет приоритет, который влияет на то, как JVM распределяет время процессора между потоками. Приоритеты потоков служат **подсказкой** для планировщика потоков JVM при принятии решения о том, какой поток выполнить следующим. Однако ==окончательное решение о распределении времени процессора зависит от реализации JVM и операционной системы.==

Потоки с более высоким приоритетом, как правило, получают больше процессорного времени, но **это не гарантирует**, что они будут всегда выполняться раньше потоков с более низким приоритетом. ==Приоритеты лишь помогают JVM принимать решение, но не являются обязательными для исполнения.==

Приоритеты потоков задаются числами от 1 до 10:

- **MIN_PRIORITY (1)**: Минимальный приоритет.
- **NORM_PRIORITY (5)**: Нормальный приоритет, который используется по умолчанию.
- **MAX_PRIORITY (10)**: Максимальный приоритет.

Приоритет потока можно установить с помощью метода `setPriority(int priority)`. Этот метод должен быть вызван **после** создания потока, но **до** его запуска методом `start()`.

## Thread Interruption

Прерывание потоков — это механизм, с помощью которого один поток может **сигнализировать** другому о необходимости остановить выполнение. Однако важно помнить, что ==прерывание не останавливает поток немедленно. Это лишь сигнал, который поток может обработать==, и сам по себе он не заставляет поток остановиться.

В Java прерывание реализовано с помощью метода `interrupt()` класса `Thread`. Этот метод устанавливает **флаг прерывания** для потока, сигнализируя, что поток был прерван. Однако ==поток должен сам проверить этот флаг и принять решение о завершении работы==.

Методы для работы с прерываниями:

- `interrupt()`: Отправляет сигнал прерывания потоку, устанавливая флаг прерывания.
- `isInterrupted()`: Проверяет, был ли поток прерван, **не сбрасывая** флаг прерывания.
- `interrupted()`: Статический метод, который проверяет флаг прерывания текущего потока и **сбрасывает его**.

