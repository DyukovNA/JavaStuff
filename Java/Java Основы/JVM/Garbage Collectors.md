### Жизненный цикл объекта

Когда в Java создается новый объект (например, через оператор `new`), JVM выделяет для него память в куче (heap). После создания объект активно используется приложением. Это означает, что на объект существуют активные ссылки из других частей кода.

Обычные ссылки в Java являются сильными ссылками. Пока на объект есть хотя бы одна сильная ссылка, он остается в памяти.
В JVM существует несколько различных алгоритмов сборки мусора, которые называются Garbage Collectors (GC). Каждый тип GC оптимизирован для конкретного вида нагрузки и характеристик приложения, поэтому их так много.

Java также предоставляет механизмы для создания слабых (`WeakReference`) и мягких (`SoftReference`) ссылок, которые позволяют GC удалять объекты, если это необходимо для освобождения памяти.

Если все сильные ссылки на объект обнулены или выходят из области видимости, объект становится недоступным для приложения.

### Генерационная гипотеза

Большинство объектов в приложении имеют короткий жизненный цикл. Они быстро создаются и также быстро становятся недоступными для использования. Относительно небольшое количество объектов используется в течение длительного времени (или в течение всего времени работы приложения).

Для оптимизации работы с различными типами объектов, JVM делит кучу (heap) на несколько "поколений" или областей:

**Young Generation:**

Здесь размещаются вновь созданные объекты. Young Generation далее делится на три части: Eden Space и две Survivor Spaces (S0 и S1). Поскольку большинство объектов в Young Generation быстро становятся "мусором", GC (Minor GC) часто и быстро очищает эту область.

**Old Generation:**

Объекты, которые выжили после нескольких циклов сборки мусора в Young Generation, перемещаются в Old Generation. Здесь объекты существуют гораздо дольше, и очистка этой области (Major GC) происходит реже, но она более трудоёмка.

**Permanent Generation или Metaspace:**

В этой области хранятся метаданные классов и другая информация на уровне приложения. В более новых версиях Java (начиная с Java 8) PermGen был заменен на Metaspace, который управляется немного иначе и хранится не в основной куче.

### Работа GC с поколениями

**Minor GC:**

Young Generation в JVM делится на три части: одну область Eden и две Survivor области (S0 и S1). Новые объекты сначала размещаются в Eden. После заполнения Eden, Minor GC инициируется.

Minor GC начинается с поиска всех живых объектов в Eden и в одной из Survivor областей (которая активна в данный момент). Живые объекты копируются из Eden и активной Survivor области в другую Survivor область. Во время этого процесса, Eden и активная Survivor область очищаются.

Объекты, которые выживают после нескольких циклов Minor GC, перемещаются из области Survivor в Old Generation. Этот процесс называется "старением" объектов.

Minor GC выполняется часто и обычно занимает небольшое время, так как работает только с небольшими областями памяти. Поскольку он копирует объекты, а не удаляет их индивидуально, это снижает фрагментацию памяти.

**Major GC или Full GC:**

Old Generation предназначена для хранения долгоживущих объектов. Эта область больше по размеру по сравнению с Young Generation.

Major GC начинается с определения всех живых объектов в Old Generation. Все недоступные объекты удаляются. В отличие от Minor GC, этот процесс может включать уплотнение, чтобы уменьшить фрагментацию памяти.

Живые объекты могут быть перемещены для уменьшения фрагментации памяти, обеспечивая эффективное использование памяти для новых объектов.

Major GC выполняется реже, но является более трудоемким, так как обрабатывает больший объем памяти. Во время Major GC, приложение может испытывать более длительные паузы, так как это Stop-The-World процесс, где выполнение всех потоков приложения приостанавливается.

Существующие типы Garbage Collectors в Java:

- **Serial GC** – последовательный сборщик мусора, который работает в одном потоке. Этот GC используется по умолчанию на малых системах и в режиме разработки.
    
- **Parallel GC** – параллельный сборщик мусора, который использует несколько потоков для выполнения операций сборки мусора. Он эффективен для крупных приложений и многопроцессорных систем.

  Запуск параллельного GC также вызывает “остановку мира” и приложение зависает. Такое поведение больше подходит для многопоточной среды, когда требуется завершить много задач и допустимы длительные паузы, например при выполнении пакетного задания.
    
- **CMS GC** – Concurrent Mark Sweep GC, который выполняет сборку мусора без блокировки всех потоков приложения. Он эффективен для приложений, где высокая производительность является критическим фактором.
  
  Тут для малой сборки мусора задействуются несколько потоков, происходит это через такой же алгоритм, как и в параллельном сборщике. Основная сборка мусора многопоточна, как и в старом параллельном GC, но CMS работает одновременно с процессами приложений, чтобы свести к минимуму события “остановки мира”.

  Из-за этого сборщик CMS потребляет больше ресурсов процессора, чем другие сборщики. Если у вас есть возможность выделить больше ЦП для повышения производительности, то CMS предпочтительнее, чем простой параллельный сборщик. В CMS GC не выполняется уплотнение.
  
- **G1 GC** – Garbage First GC, который основан на принципе разделения кучи на несколько регионов и использовании эвристических методов для определения регионов, подлежащих очистке. Он подходит для крупных приложений с большим объемом данных и обеспечивает высокую производительность. 

Каждый GC имеет свои сильные и слабые стороны, поэтому выбор определенного типа зависит от характеристик приложения и требований к его производительности. Например, если важна быстрая загрузка приложения на маленьких системах, то Serial GC может быть лучшим выбором. Если же приложение запущено на крупной системе с многопроцессорностью и многопоточностью, то Parallel GC или G1 GC могут работать более эффективно.

Определенный тип GC можно задать при запуске JVM с помощью аргументов командной строки. Например, для использования G1 GC нужно указать флаг -XX:+UseG1GC. Однако, в большинстве случаев не требуется явно выбирать тип GC, так как JVM использует оптимальный GC для конкретных условий работы приложения.