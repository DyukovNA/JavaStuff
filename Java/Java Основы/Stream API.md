Stream API — это мощный инструмент для обработки данных, который идеально подходит для ряда задач, но ==не является универсальным решением.== Его применение оправдано, если ваша задача вписывается в следующий шаблон:

1. **Источник данных** — это коллекция или другая структура, содержащая элементы.
2. **Выполнение преобразований** — это фильтрация, сортировка, маппинг и другие операции над элементами.
3. **Сохранение результата** — это помещение преобразованных данных в новую структуру (например, список, множество и т.д.).

```java
public void printSpecies(List<SeaCreature> seaCreatures) {
    seaCreatures.stream()
        .filter(sc -> sc.getWeight() >= 10)
        .map(SeaCreature::getSpecies)
        .distinct()
        .sorted(Comparator.comparing(Species::getPopulation))
        .map(Species::getName)
        .forEach(System.out::println);
}
```

![[Снимок экрана 2025-01-21 в 09.47.29.png]]

Stream API поддерживает множество типов источников данных. Поток может быть создан из коллекций, массивов, строк, файлов и других структур.
Исходные данные не изменяются при работе с потоками — все преобразования происходят в новом потоке, а результат сохраняется в новой структуре данных.

Операции Stream API можно разделить на два типа: **промежуточные** и **терминальные**. Терминальные операции завершают работу потока и возвращают результат. После вызова терминальной операции поток нельзя вызвать повторно. Выполнение промежуточных операций откладывается до вызова терминальной операции.

#### Как работает Stream?
Stream API в Java обрабатывает данные с помощью цепочек промежуточных и терминальных операций, но важная особенность заключается в том, что ==каждый элемент потока проходит через весь пайплайн поэтапно==. Операции не применяются к коллекции целиком, а работают над каждым элементом поочередно.

#### Stateless и Stateful операции

Операции в Stream API делятся на два типа: **stateless** (без состояния) и **stateful** (с состоянием), в зависимости от того, как они обрабатывают элементы потока.

==Операции без состояния, такие как `map()` и `filter()`, обрабатывают каждый элемент потока независимо от других.== Они не требуют информации о предыдущих или последующих элементах для своей работы, что делает их идеально подходящими для параллельной обработки. Например, в методе `filter()` каждый элемент проверяется по заданному условию отдельно, и его результат не зависит от других элементов.

==Операции с состоянием, такие как `sorted()`, `distinct()` или `limit()`, требуют информации о других элементах потока. Эти операции не могут начать возвращать результаты, пока не обработают часть или весь поток.== Например, `sorted()` должна сначала собрать все элементы, чтобы их отсортировать, а затем уже передать их на последующие этапы.

Если в пайплайне используются только операции без состояния, то поток может быть обработан “в один проход”, что делает выполнение быстрым и эффективным. Однако ==при добавлении операций с состоянием поток делится на секции, и каждая секция должна завершить свою обработку перед началом следующей.==

#### Spliterator
В основе всех коллекций в Java лежит интерфейс `Iterator`, который позволяет последовательно перебирать элементы. Однако для работы с потоками данных в Stream API используется более мощный механизм — ==`Spliterator`, своего рода “итератор на стероидах”. Его ключевая особенность — возможность разделять данные для независимой обработки разными потоками.==

### Что же такое Stream?

==В основе Stream API лежит концепция потоков, которые представляют собой последовательность операций, выполняемых над данными.== Потоки позволяют обрабатывать коллекции данных на более высоком уровне абстракции, предоставляя удобные и эффективные средства для манипуляции с данными.

Основные свойства потоков:

1. **Декларативность**: Потоки в Java ==позволяют описывать что нужно сделать с данными, а не как это должно быть реализовано.== Вместо явного использования циклов и условий, разработчик может задать набор операций, которые Java выполнит под капотом. Такой подход повышает читаемость и простоту кода, поскольку скрывает сложные детали реализации.
2. **Ленивость**: ==Операции в потоке не выполняются сразу — они “откладываются” до тех пор, пока не будет вызвана терминальная операция.== Это позволяет Java оптимизировать выполнение операций, обрабатывая данные по мере необходимости и избегая лишней работы.
3. **Одноразовость**: Потоки можно использовать только один раз. ==Как только была вызвана терминальная операция, поток считается исчерпанным и больше не может быть использован.== Если необходимо выполнить другую операцию над теми же данными, нужно создать новый поток.
4. **Параллельность**: Потоки по умолчанию выполняются последовательно, но их можно легко распараллелить, используя метод `parallelStream()` или `parallel()`. Это позволяет значительно ускорить обработку больших наборов данных на многоядерных системах. Параллельные потоки автоматически разделяют данные на части и распределяют задачи между несколькими потоками, обеспечивая более эффективное использование ресурсов процессора

**Место расположение `.parallel()` в Pipline**

Может возникнуть вопрос: важно ли, на каком этапе пайплайна вызывается метод `parallel()`?

![](https://struchkov.dev/blog/ru/content/images/2023/07/screen-765.png)

Ответ — нет, ==расположение метода в цепочке не влияет на поведение потока==. Вызов `parallel()` лишь устанавливает характеристику `CONCURRENT`, что переводит поток в параллельный режим. Аналогично, вызов метода `sequential()` отменяет эту характеристику и возвращает поток в последовательный режим.