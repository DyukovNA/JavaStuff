Уровень изоляции (изоляция или изолированность — определяет, как транзакции могут взаимодействовать между собой и насколько сильно могут пересекаться и мешать друг другу при параллельной работе.
Разные уровни изоляции допускают или не допускают разные **аномалии** при параллельной работе транзакций (про аномалии расскажем дальше).

Что касается аномалий, то в примерах мы рассмотрели основные 3 **аномалии:**

- **Потерянное обновление (Lost Update)** - две транзакции меняют одни и те ж данные. Одна транзакция откатывает изменения, в результате чего откатываются изменения предыдущей. Т.е. Rollback одновременно (или после) с Commit. Не происходит в современных СУБД![[Снимок экрана 2025-02-16 в 12.47.07.png]]
- **Грязное чтение (Dirty Read)** - одна транзакция читает данные, которые изменяет другая. Другая потом откатывается, а первая продолжает работать с грязными данными![[Снимок экрана 2025-02-16 в 12.48.41.png]]
- **Неповторяющееся чтение (Non-repeatable Read)** - в рамках одной транзакции два одинаковых запроса возвращают разные данные, т.к. другая транзакция обновила данные во время работы первой.![[Снимок экрана 2025-02-16 в 12.50.48.png]]Или записывается только последний коммит
![[Снимок экрана 2025-02-16 в 12.53.03.png]]
- **Фантомное чтение (Phantom Read)** - 1 транзакция читает данные, после чего 2 вставляет/удаляет строки. 1 транзакция повторно читает и получает другой результат.![[Снимок экрана 2025-02-16 в 12.56.39.png]]
Всего есть 4 основных уровня изоляции:

- **READ UNCOMMITTED**
    
- **READ COMMITTED**
    
- **REPEATABLE READ**
    
- **SERIALIZABLE**

![[Pasted image 20250126132604.png]]

Давайте каждый из уровней разберём подробно:

### READ UNCOMMITTED

Это самый слабый уровень изоляции, когда **транзакция может видеть результаты других транзакций, даже если они ещё не закоммичены**. Но нельзя сделать роллбек так, чтобы сделать роллбек уже закоммиченным данным

По факту, тут изоляция отсутствует. Где‑нибудь в аналитике больших данных такой уровень может ещё использоваться, где нам не так важна точность данных, но это достаточно редко.

### READ COMMITTED

На этом уровне **транзакция может читать только те изменения в других параллельных транзакциях, которые уже были закоммичены**. Это нас **спасает от грязного чтения, но не спасает от неповторяющегося чтения и от фантомного чтения**. 

Такой уровень по умолчанию используется, например, в PostgreSQL, MS SQL и Oracle

### REPEATABLE READ

Этот уровень означает, что **пока транзакция не завершится, никто параллельно не может изменять или удалять строки, которые транзакция уже прочитала**. 

Это нас **спасает и от грязного чтения, и от неповторяющегося чтения, но всё ещё мы не решаем проблему фантомного чтения**. Почему? Конечно, строки, которые я уже прочитал в транзакции, никто не изменит, но никто не мешает добавлять новые строки параллельно - их мы ещё не читали, создавать их ничего не мешает.

### SERIALIZABLE

Самый жёсткий, но самый тяжёлый для БД и медленный для обработки запросов уровень. Он **блокирует любые действия, пока запущена транзакция** — получается, транзакции идут строго одна за другой и максимально изолируются друг от друга. Это достигается с помощью блокировки всей таблицы от любых взаимодействий с ней, но некоторые СУБД делают менее радикально — блокируют только те строки, которые задействует текущая транзакция.

Тут никакие аномалии нам не страшны — ни грязное, ни неповторяемое, ни фантомное чтение. Но и производительность тут страдает, ведь транзакции не могут работать параллельно.