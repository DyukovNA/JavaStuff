### 3-level model 

![[Снимок экрана 2025-02-17 в 13.54.10.png]]

В Tomcat загружались .war (информация про веб) файлы и там выполнялись

![[Снимок экрана 2025-02-17 в 13.54.26.png]]

### Spring MVC через паттерн Front Controller

Паттерн Front Controller - когда есть один сервлет, который принимает все запросы и перенаправляет их на нужный контроллер.

Мы как программисты будем писать контроллеры а не сервлеты, Dispatcher Servlet будет предоставлен спрингом

![[Снимок экрана 2025-02-17 в 13.58.27.png]]

В случае Spring Boot у нас есть встроенный Tomcat
Раньше: загружаем в томкат
Сейчас: собирается .jar файл со встроенным томкатом

![[Снимок экрана 2025-02-17 в 13.59.36.png]]

Во встроенном томкате нет Jasper'a, т.к. jsp - устаревший формат и движок нам больше не нужен. Но его можно добавить при помощи зависимостей

![[Снимок экрана 2025-02-17 в 14.01.32.png]]

### Что будет происходить с Dispatcher Servlet'ом

![[Снимок экрана 2025-02-17 в 14.02.31.png]]

1. Запросы от клиента принимает Coyote - у него есть http-коннекторы.
2. Coyote отправляет запросы на Catalina. Она уже создаёт запросы, которые умеют обрабатывать сервлеты
	1. Сам сервлет проходит этапы:
		- Загрузка класса
		- Новый инстанс
		- Вызов метода init() один раз при старте сервлета. 
	2. Затем будет вызываться только сервис, который будет перенаправлять запросы в отличие от их вида (GET, POST, PUT, DELETE)
	3. destroy() при завершении работы сервлета

### Как работает Dispatcher Servlet
![[Снимок экрана 2025-02-17 в 14.44.25.png]]

1. Определяет на какой хендлер (т.е. контроллер) отправить запрос методом getHandler(). Отправляется на нужный контроллер
2. Создание хендлер адаптера в котором: 
	1. Создаётся контекст (можем инжектить бины), 
	2. подставляются значения из .properties в методы и аргументы, инжектится что нужно в параметры методов
	3. Анализируется результат выполнения методов
3. Результатом работы хендлера будет ModelAndView
	- Раньше за View отвечал JSP, мы возвращали модель и при помощи {$...} подставляли значения в JSP - **Рендеринг**
	- Сейчас если ModelAndView != нулл, то рендерится на стороне сервера и возвращается клиенту
	- Если нулл, то рендеринг на стороне клиента. В этом случае указываем аннотацию @ResponseBody [[Spring REST]]
	- Если произошло исключение то есть их обработчики

Мы как программисты пишем:
- Контроллеры - в них делаем мапинг, по которому хендлеры понимают, куда какой запрос предназначается
- Интерсепторы - реализация фильтров - для анализа запроса перед тем как он попадёт в сервлет