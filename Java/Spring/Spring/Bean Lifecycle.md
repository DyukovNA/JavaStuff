![[Снимок экрана 2025-02-16 в 16.25.07.png]]
![[Снимок экрана 2025-02-16 в 21.48.23.png]]

**IoC Container находится в контексте**

Чтобы получить экземпляр бина, применяют ApplicationContext

**Цикл**:
1. Постобработка BeanDefinitions (описание того, как нужно конфигурировать бины) - любые манипуляции с ними, например замена каких-то данных на значения из .properties 
2. Сортировка BeanDefinitions - того, что мы написали в xml или задали другим путём. 
	
	Для чего сортируем: DTO, например могут быть написаны в самом конце, но при этом DTO ни от чего не зависит, а маппер зависит от DTO. Поэтому если мы попытаемся создать объект маппера, то будет ошибка, если ещё не существует объекта DTO.
	
	Поэтому создаётся список Definitions, отсортированных в нужном порядке, а затем циклом forEach перебираются и проходят следующие этапы
	
2. Вызов конструктора
3. Вызов сеттера
4. Инициализация:
	1. Обработка аннотаций перед инициализацией(Например @Autowired, @PostConstruct - последний)
	2. Вызов метода init()
	3. Обработка аннотаций после инициализации
5. Хранение в IoC контейнере - это хранение в мапе имя - бин. Хранятся только синглтоны (потому что мапа), а прототайпы передаются тем, кто их запрашивал и в мапе не хранятся.
6. Уничтожение бинов из контейнера. Происходит только при вызове метода close() у контекста
	1. PreDestroy
	2. close()
	

### Bean Scopes

![[Снимок экрана 2025-02-16 в 20.36.12.png]]

Bean Scopes - видимость бинов

В Spring Framework имеются пять возможных значений свойства scope:

**singleton**

Определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию).

**prototype**

Позволяет иметь любое количество экземпляров бина.

**thread**

Один на поток

**request**

Создаётся один экземпляр бина на каждый HTTP запрос. Касается исключительно ApplicationContext.

**session**

Создаётся один экземпляр бина на каждую HTTP сессию. Касается исключительно ApplicationContext.

**application**

На протяжении всего приложения

**websocket**

Пока существует сокет




Через следующие этапы проходит каждый _отдельно взятый_ бин:  
  
**1. Инстанцирование объекта**. Техническое начало жизни бина, работа конструктора его класса;  
  
**2. Установка свойств** из конфигурации бина, [внедрение зависимостей](https://itsobes.com/ru/java/kak-spring-framework-realizuet-pattern-dependency-injection);  
  
**3. Нотификация aware-интерфейсов**. `BeanNameAware`, `BeanFactoryAware` и другие. Мы уже писали о таких интерфейсах [ранее](https://itsobes.com/ru/java/kogda-ispolzuiut-aware-interfeisy-v-spring). Технически, выполняется системными подтипами `BeanPostProcessor`, и совпадает с шагом 4;  
  
**4. Пре-инициализация** – метод `postProcessBeforeInitialization()` интерфейса `BeanPostProcessor`;  
  
**5. Инициализация.** Разные способы применяются в таком порядке:  
**•** Метод бина с аннотацией `@PostConstruct` из стандарта JSR-250 (рекомендуемый способ);  
**•** Метод `afterPropertiesSet()` бина под интерфейсом `InitializingBean`;  
**•** Init-метод. Для отдельного бина его имя устанавливается в параметре определения `initMethod`. В xml-конфигурации можно установить для всех бинов сразу, с помощью `default-init-method`;  
  
**6. Пост-инициализация** – метод `postProcessAfterInitialization()` интерфейса `BeanPostProcessor`.

![Опишите жизненный цикл Spring Bean](https://itsobes.com/assets/ru/java/303.jpg)

Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами [финализации](https://itsobes.com/ru/java/finalize) в Java, при жестком выключении (`kill -9`) гарантии вызова этого этапа нет. Три альтернативных способа «деинициализации» вызываются в том же порядке, что симметричные им методы инициализации:  
  
**1.** Метод с аннотацией `@PreDestroy`;  
**2.** Метод с именем, которое указано в свойстве `destroyMethod` определния бина (или в глобальном `default-destroy-method`);  
**3.** Метод `destroy()` интерфейса `DisposableBean`.  
  
Не следует путать жизненный цикл отдельного бина с жизненным циклом контекста и этапами подготовки фабрик бинов. О них мы поговорим в будущих публикациях.