**Spring** — один из самых популярных фреймворков для создания веб-приложений на Java. 

Java EE задают спецификацию, а Spring её реализует

Цель Spring Framework состоит в том, чтобы «упростить» доступную функциональность Java, подготовить ее к внедрению зависимостей и, следовательно, упростить использование API в контексте Spring.

Фреймворк отличается от библиотеки тем, что библиотека предоставляет классы и методы (мы создаём объекты классов и используем методы), а фреймворк создаёт объекты классов и использует методы сам, от пользователя ему нужно только описание классов и части логики. 

В спринге стараются по максимуму отойти от жесткой связности (когда ваши классы напрямую зависят от каких-то классов/интерфейсов из этого фреймворка), и используют для этой цели аннотации.

Но спринг — это скорее общее названия для целого ряда небольших фреймворков, каждый из которых выполняет какую-то свою работу.
- **Spring core** - реализует IoC через Dependency Injection
- Spring AOP - аспектно-ориентирование программирование
- Spring Data - для работы с Hibernate
- Spring Web
- Spring Security
- **Spring Boot** - фреймворк фреймворков, который конфигурирует перечисленные выше фреймворки![[Снимок экрана 2025-02-16 в 15.57.38.png]]
- Spring Cloud и Actuator - для микросервисов

#### Бины и контекст

Одно из ключевых понятий в спринге — это **бин**. По сути, это просто объект какого-то класса.

 **Контекст** (_**application context**_) — это набор бинов (объектов). Обращаясь к контексту — мы можем получить нужный нам бин (объект) по его имени например, или по его типу, или еще как-то. Кроме того, мы можем попросить спринг самого сходить поискать в своем контексте нужный нам бин и передать его в наш метод.

## Spring AOP (Аспектно-ориентированное программирование) и прокси

Spring читает конфигурацию, содержащую метод `@Bean`, который вы написали, и поэтому Spring знает, как создавать и внедрять компоненты UserService.

Однако Spring может обманывать и создавать что-то **еще**, кроме вашего класса UserService. Как? Почему?

### Spring может создавать прокси

Потому что под капотом любой метод Spring `@Bean` может вернуть вам то, что (в вашем случае) **_выглядит и ощущается как_** UserService, но на самом деле это не так.

Он может вернуть вам _прокси_.

In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be [forwarding](https://en.wikipedia.org/wiki/Forwarding_(object-oriented_programming) "Forwarding (object-oriented programming)") to the real object, or can provide additional logic.

Короче это интерфейс, добавляющий ещё какой-то логики

Прокси-сервер в какой-то момент делегирует службу UserService, которую вы написали, но сначала он выполнит свою **собственную функциональность**.

### Почему Spring желает создавать прокси?

Потому что это позволяет Spring дать **вашим** компонентам дополнительные функции без изменения кода. В сущности, это то, что является аспектно-ориентированным (или: AOP) программированием.

Давайте рассмотрим **самый популярный** пример AOP — аннотацию Spring `@Transactional`.

1. Мы написали метод activUser, который при вызове должен выполнить некоторый SQL-запрос, чтобы обновить состояние пользователя в базе данных, возможно, отправить сообщение электронной почты или событие обмена сообщениями.
2. `@Transactional` для этого метода сигнализирует Spring, что для работы этого метода необходимо открытое соединение с базой данных / транзакция и что указанная транзакция также должна быть зафиксирована в конце. И Spring должна сделать это.

Проблема: хотя Spring может создать ваш компонент UserService через конфигурацию applicationContext, он не может переписать ваш UserService. Он не может просто вставить туда код, который открывает соединение с базой данных и фиксирует транзакцию с базой данных.

Но что она **может сделать**, так это создать прокси вокруг вашего UserService, который будет транзакционным. Таким образом, только прокси-сервер должен знать, как открывать и закрывать соединение с базой данных, а затем может просто делегировать его вашему UserService.

## Управление ресурсами Spring

Подумайте, как бы вы попытались получить доступ к файлу в Java через HTTP или FTP. Вы можете использовать [класс URL в Java](https://docs.oracle.com/javase/7/docs/api/java/net/URL.html) и написать некоторый код.

Короче говоря, Spring дает вам возможность доступа к ресурсам с помощью приятного небольшого синтаксиса. Интерфейс ресурса имеет несколько интересных методов:
- Это существует?
- Какое имя файла?
- Получить ссылку на фактический объект File.
- Получить прямую ссылку на необработанные данные (InputStream).

### Что такое Spring Environment?

  

Большая часть любого приложения — это чтение свойств (properties), таких как имя пользователя и пароли базы данных, конфигурация почтового сервера, детализированная конфигурация оплаты и т.д.

  

В простейшем виде эти свойства находятся в файлах .properties, и их может быть много:

  

- Некоторые из них на вашем classpath, так что у вас есть доступ к некоторым паролям, связанным с разработкой.
- Другие в файловой системе или на сетевом диске, поэтому рабочий сервер может иметь свои собственные, защищенные свойства.
- Некоторые могут даже прийти в форме переменных среды операционной системы.

  

Spring пытается упростить вам регистрацию и автоматический поиск свойств во всех этих различных источниках с помощью абстракции _environment_.

1. Через applicationContext вы всегда можете получить доступ к текущей среды (**_environment_**) выполняемого Spring приложения.
2. Среда (**_environment_**), с другой стороны, позволяет вам, помимо прочего, получать доступ к свойствам.

### Что такое Spring `@PropertySources`?

  

В двух словах, среда состоит из одного или многих источников свойств выполняемого Spring приложения.

[По умолчанию](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction) среда веб-приложения Spring MVC состоит из параметра ServletConfig/Context, источников системных свойств JNDI и JVM. Они также являются иерархическими, это означает, что они имеют порядок важности и перекрывают друг друга.

Аннотация `@PropertySource` работает с любым допустимым классом конфигурации Spring и позволяет вам определять новые дополнительные источники с помощью абстракции ресурсов Spring: помните, что все дело в префиксах: http://, file://, classpath: и т.д.,
## Spring Web MVC

Spring Web MVC, также известный как Spring MVC, является веб-средой Spring. Это позволяет создавать все, что связано с сетью, от небольших веб-сайтов до сложных веб-сервисов. Он также поддерживает фреймворки, такие как Spring Boot.

![[Pasted image 20250125190631.png]]

В контексте рендеринга HTML-страниц, скажем, страницы учетной записи пользователя, вот как выглядит **MVC** в Spring:

- Ваша **Model (модель)** содержит данные, которые вы хотите отобразить на веб-странице. Однако данные полностью независимы от вашего HTML, это простые объекты Java (например, объекты пользователя), из которых состоит ваше приложение.
- Ваше **View (представление)** будет HTML-шаблоном, который является каркасом для вашей HTML-страницы, написанной с определенной библиотекой шаблонов. Эти библиотеки позволяют включать заполнители в ваши шаблоны, которые позволяют получить доступ к данным модели, например, имени пользователя.
- **Controller (Контроллер)** будет аннотированным методом `@Controller`, который отвечает на HTTP-запрос /account и знает, как преобразовать HTTP-запрос в объекты Java, а также ваши объекты Java в ответ HTML.

### HttpServlet памятка

На данный момент игнорируем MVC: чтобы написать что-нибудь, связанное с HTTP с Java, вы бы использовали сервлеты или, в частности, HttpServlets (примечание для придир: да, есть и другие способы, спасибо за замечание). Сервлеты могут обрабатывать HTTP-запросы, а также возвращать браузеру или клиенту соответствующий HTTP-ответ.  

После написания вашего сервлета вы должны зарегистрировать его в контейнере сервлетов, таком как [Tomcat](https://tomcat.apache.org/) или [Jetty.](https://www.eclipse.org/jetty/) Регистрация сервлета всегда включает путь, чтобы указать, за какие URL в вашем веб-приложении отвечает ваш сервлет. Давайте предположим путь "/*", поэтому каждый входящий HTTP-запрос к вашему приложению обрабатывается одним сервлетом.

1. Ваш сервлет должен расширить Java HttpServlet.
2. Вы можете переопределить метод doGet(), чтобы обрабатывать запросы Http GET. С отображением сервлета "/" это означает для всех запросов GET. Таким образом, запрос «/status», «/info», «/account» в конечном итоге будет выполнен в одном и том же методе doGet.
3. Вы можете переопределить метод doPost() для обработки запросов POST Http. С отображением сервлета "/" это означает для всех запросов POST. Таким образом, отправка форм в «/register», «/submit-form», «/password-recovery» в конечном итоге будет осуществляться одним и тем же методом doPost().

Обрабатывать каждый запрос к вашему приложению всего двумя способами — это немного громоздко, и для того, чтобы получить правильный MVC, требуется довольно много работы.

  

Кроме того, вашему MyServlet (контроллеру) необходимо выполнить довольно много ручного HTTP-специфического подключения, проверки URI запроса, просмотра строк, преобразования requestParameters и ответов и так далее.

  

Было бы намного приятнее, если бы вам не пришлось заботиться обо всем этом слесарном деле и позволить Spring сделать это за вас. Вот тут и приходит DispatcherServlet.

  

### Что делает DispatcherServlet?

  

Uber-контроллер в среде Spring MVC Spring представляет собой сервлет, который называется **DispatcherServlet**.

  

Он называется DispatcherServlet, потому что он может буквально обрабатывать любой входящий HTTP-запрос, анализировать его содержимое и пересылать данные в виде симпатичных маленьких объектов Java в класс Controller.

Он также достаточно умен, чтобы брать выходные данные с этих контроллеров и конвертировать их в HTML / JSON / XML, в зависимости от того, что подходит. Весь процесс выглядит следующим образом (с пренебрежением большим количеством промежуточных классов, потому что DispatcherServlet не выполняет всю работу сам).

### Как писать классы типа Controller

  

Наконец, мы можем написать наш **Controller** класс, который обрабатывает запросы /account.

  

Страница /account будет HTML-страницей с несколькими динамическими переменными, такими как имя пользователя, адрес, информация о подписке и т.д.

![[Снимок экрана 2025-01-25 в 19.24.05.png]]

У вас есть класс AccountController, который аннотируется `@Controller`. Он сообщает Spring: этот класс хочет реагировать на HTTP-запросы и ответы, чтобы DispatcherServlet знал об этом.

  

У вас есть простой Java-метод, называемый account(). Что еще интереснее, метод аннотируется `@GetMapping`. Это сообщает DispatcherServlet, что все запросы, похожие на /account/{userId}, должны обрабатываться именно этим методом контроллера. Более того, dispatcherServlet возьмет {userId}, преобразует его в целое число и использует его в качестве параметра метода!

  

Наш метод Java возвращает строку с именем account. На самом деле это не просто строка, а ссылка на представление (HTML-шаблон). Давайте посмотрим на эти шаблоны на секунду.

### Как генерировать JSON / XML (представления) с помощью Spring Web MVC
![[Снимок экрана 2025-01-25 в 19.26.07.png]]

1. На этот раз вы добавляете дополнительную аннотацию `@ResponseBody` в метод контроллера, который сообщает Spring, что вы хотите записать свой Java-объект HealthStatus непосредственно в HttpResponse (например, в виде XML или JSON).
2. Вы просто возвращаете простой Java-объект внутри вашего метода, а не строковую ссылку на ваше представление.

### Как работает согласование контента (content negotiation) Spring MVC

  

Существует множество способов, с помощью которых вы, как клиент, можете указать Spring MVC, какой формат ответа вы хотите при выполнении запроса к приложению Spring MVC.

- Указав заголовок Accept, такой как «Accept: application/json» или «Accept: application/xml». Это работает "из коробки", но требует определенных библиотек в вашем пути к классам для поддержки сортировки XML или JSON.
- Добавив расширение URL к вашему пути запроса, например /health.json или /health.xml. Это требует настройки на стороне Spring MVC для работы.
- Добавив параметр запроса в путь запроса, например /health?Format = json. Это требует настройки на стороне Spring MVC для работы.

Затем Spring знает: вы аннотировали этот метод с помощью `@ResponseBody`, и клиент хочет «JSON». У меня есть библиотека на пути к классам, как Джексон, которая может визуализировать JSON? Если да, хорошо, давайте преобразуем HealthStatus в JSON. В противном случае выведите исключение.

==Spring MVC `@RestController` — это не что иное, как Spring MVC `@Controller` в сочетании с аннотацией Spring MVC `@ResponseBody` — хотя вы можете подумать, что это что-то связанное со Spring Boot.==
### Какой тип ввода HTTP-запроса понимает Spring?

  

Spring MVC понимает в основном все, что предлагает HTTP — с помощью сторонних библиотек.

  

Это означает, что вы можете выбросить в него тела запросов JSON, XML или HTTP (Multipart) Fileupload, и Spring удобно преобразует этот ввод в объекты Java.

  

### Какие HTTP-ответы может написать Spring MVC?

  

Spring MVC может записывать все что угодно в HttpServletResponse — с помощью сторонних библиотек.

  

Будь то HTML, JSON, XML или даже тела ответов WebSocket. Более того, он берет ваши объекты Java и генерирует эти тела ответов для вас.

### В чем разница между Spring и Spring Boot?

  

Если вы прочитали это руководство, вы должны понимать, что Spring Boot построен поверх Spring. Несмотря на то, что скоро появится подробное руководство по Spring Boot, вот пример того, что означают «самоуверенные значения по умолчанию» в Spring Boot.

  

Spring предлагает вам возможность читать .properties файлы из разных мест, например с помощью аннотаций `@PropertySource`. Он также предлагает вам возможность писать контроллеры JSON REST с помощью своей инфраструктуры Web MVC.

  

Проблема в том, что вы должны сами написать и настроить все эти отдельные части. Spring Boot, с другой стороны, берет эти отдельные части и связывает их вместе. Пример:

  

- **Всегда и автоматически** ищите файлы application.properties в разных местах и ​​читайте их.
- **Всегда загружайте встроенный Tomcat,** чтобы вы могли сразу увидеть результаты работы ваших Rest контроллеров.
- **Автоматически** настраивайте все для отправки / получения JSON, не беспокоясь о конкретных зависимостях Maven / Gradle.

### В чем разница между Spring и Spring Batch?

  

Spring Batch — это фреймворк, упрощающий написание пакетных заданий, т.е. «Читать эти 95 CSV-файлов каждую ночь в 3 часа ночи и вызывать внешнюю службу проверки для каждой записи».

  

Опять же, он построен на основе Spring Framework, но во многом является собственным проектом.

  

Тем не менее, обратите внимание, что по сути **невозможно** создать надежное пакетное задание без хорошего понимания общего управления транзакциями в Spring Framework и его отношения к Spring Batch.


### В чем разница между Spring и Spring Web MVC?

  

Если вы прочитали это руководство, вы должны понимать, что Spring Web MVC является частью среды Spring.

  

На очень высоком уровне это позволяет вам превратить ваше Spring-приложение в веб-приложение с помощью DispatcherServlet, который маршрутизирует классы `@Controller`.

  

Это могут быть RestControllers (где вы отправляете XML или JSON клиенту) или старые добрые HTML-контроллеры, где вы генерируете HTML с такими фреймворками, как Thymeleaf, Velocity или Freemarker.

