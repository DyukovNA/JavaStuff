### Что такое HTTP

**HTTP** —  протокол передачи гипертекста. Прикладной уровень в сетевой модели OSI. 
Основа WWW

Гипертекст - специальный тип разметки, которая добавляется в текстовые документы, чтобы определить как показывать тут или иную часть текста

В HTML используются теги

HTTP использует протокол TCP, порт сервера - 80, порт клиента генерируется автоматически операционной системой

Соединение TCP можно установить один раз и использовать его для загрузки ресурсов

Нет жёсткого формата пакетов. Используется текстовый режим

![[Снимок экрана 2025-02-17 в 17.01.36.png]]
![[Снимок экрана 2025-02-17 в 17.02.48.png]]
![[Снимок экрана 2025-02-17 в 17.04.07.png]]


**HTTPS (HTTP _Secure_**) — это надстройка над протоколом HTTP, которая поддерживает шифрование посредством криптографических протоколов SSL и TLS. Они шифруют отправляемые данные на клиенте и дешифруют их на сервере. Это защищает данные от чтения злоумышленниками, даже если им удастся их перехватить.













### Статусы ответов

Клиенту зачастую недостаточно просто отправить запрос на сервер. Во многих случаях надо дождаться ответа и понять, как сервер обработал запрос. Для этого были придуманы статусы ответов. Это трёхзначные числовые коды с небольшими текстовыми обозначениями. Их можно увидеть в терминале или браузере. Сами коды делятся на 5 классов:

- Информационные ответы: коды 100–199
    
- Успешные ответы: коды 200–299
    
- Редиректы: коды 300–399
    
- Клиентские ошибки: коды 400–499
    
- Серверные ошибки: коды 500–599


### Тело запроса и ответа

Тело запроса опционально и всегда отделяется от заголовков пустой строкой. А как понять, где оно заканчивается? Всё кажется очевидным: где кончается строка, там и заканчивается тело. Однако, два символа переноса строки в HTTP означают конец запроса и отправляют его на сервер. Как быть, если мы хотим передать в теле текст, в котором есть несколько абзацев с разрывами в две строки?

```
POST /path HTTP/1.1
Host: localhost

Первая строка


Вторая строка после разрыва
```

По логике работы HTTP соединение отправится сразу после второй пустой строки и сервер получит в качестве данных только строку `Первая строка`. Описанную проблему решает специальный заголовок `Content-Length`. Он указывает на длину контента в байтах. Обычно клиенты (например, браузеры) автоматически считают длину передаваемых данных и добавляют к запросу заголовок с этим значением. Когда сервер получит запрос, он будет ожидать в качестве контента ровно столько байт, сколько указано в заголовке.

Однако, этого недостаточно для того, чтобы передать данные на сервер. Поведение зависит от реализации сервера, но для большинства из них необходимо также передать заголовок _Content-Type_. Он указывает на тип передаваемых данных. В качестве значения для этого заголовка используют MIME-типы.4

**Запрос на отправку данных будет выглядеть так:** 

```
POST /login HTTP/1.0
Host: example.com
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 26
login=user&password=qwerty
```

Тут есть небольшая особенность. Как понять, где заканчивается ключ и начинается его значение, если в пароле будет присутствовать знак «=» ?

```
POST /login HTTP/1.0
Host: example.com
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 26
login=user&password=123=45
```

В этом случае сервер не сможет понять, как разбить строку на параметры и их значения. На самом деле значения кодируются при помощи механизма url encoding.5 При использовании этого механизма знак «=» будет преобразован в код `%3D` .

**Тогда наш запрос приобретёт такой вид:**

```
POST /login HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 28

login=user&password=123%3D45
```

## Запросы

POST - Create
GET - Read
PUT - Update
DELETE - Delete
### Query string

Данные на сервер можно передавать через тело запроса и через так называемую строку запроса Query String. Это параметры формата _ключ=значение_, которые располагаются в пути к ресурсу:

```
GET /files?key=value&key2=value2 HTTP/1.0
```

При этом параметры можно передавать прямо от корня домена:

```
GET /?key=value&key2=value2 HTTP/1.0
```

Query String имеет такой же формат, как и тело запроса с MIME `application/x-www-form-urlencoded`_,_ только первая пара значений отделяется от адреса вопросительным знаком.

Некоторые инженеры ошибочно полагают, что Query String являются параметрами GET-запроса и даже называют их GET-параметрами, но на самом деле это не так. Как и тело запроса, Query String не имеет привязки к HTTP-методам и может передаваться с любым типом запросов.

Обычно параметры Query String используются в GET-запросах, чтобы конкретизировать получаемый ресурс. Например, можно получить на сервере список файлов, имена которых будут начинаться с переданного значения. 

GET-запросы по своей идеологии должны быть идемпотентными. Это значит, что множественный вызов метода с одними и теми же параметрами должен приводить к одному и тому же результату. Например, поисковые боты перемещаются по сайту только по ссылкам и делают только GET-запросы, потому что исходя из семантики они не смогут таким образом изменить данные на сайте и повлиять на его работу.

На этом я закончу говорить про версию протокола 1.0, структуру ответов и запросов. В следующей статье я расскажу, что такое Cookies, для чего нужен CORS и как это всё работает. А пока напоследок оставлю полезные ссылки, которые упомянул в тексте: